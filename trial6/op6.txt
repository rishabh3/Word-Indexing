Enter File Name:
The File Name entered is:ip1.txt.

The number of characters read : 3077

The total number of unique words are : 530
﻿Pattern matching is to find a pattern, which is relatively small, in a text, which is supposed to be very large Patterns and texts can be one-dimensional, or two dimensional In the case of one-dimensional, examples can be text editor and DNA analysis In the text editor, we have 26 characters and some special symbols, whereas in the DNA case, we have four characters of A, C, G, and T In the text editor, a pattern is often a word, whose length is around 10, and the length of the text is a few hundred up to one millionq In the DNA analysis, a gene in a few hundred long and the human genome is about 3 billion long In the case of two-dimensional, the typical application is a pattern matching in computer vision A pattern is about (100, 100) and text typically (1024,1024) Either one-dimensional or two-dimensional, the text is very large, and therefore a fast algorithm to find the occurrence(s) of pattern in it is needed We start from a naive algorithm for one-dimensional At first the pattern is set to the left end of the text, and matching process starts After a mismatch is found, pattern is shifted one place right and a new matching process starts, and so on The pattern and text are in arrays pat[1m] and text[1n] respectively Although there are a few thousand variations of the computer with different archi-tectures and internal organization, it is best to think about them at the level of the assembly language Despite architectural variations, the assembly level language sup- port is very similar - the major difference being in the number of registers and the word length of the machine But these parameters are also in a restricted range of a factor of two, and hence asymptotically in the same ball park In summary, think about any computer as a machine that supports a basic instruction set consisting of arithmetic and logical operations and memory accesses (including indirect addressing) We will avoid cumbersome details of the exact instruction set and assume realistically that any instruction of one machine can be simulated using a constant number of available instruction of another machine Since analysis of algorithms involves counting the number of operations and not the exact timings (which could differ by an order of magnitude), the above simplification is justified The careful reader would have noticed that during our detailed analysis of Method 3 in the previous sections, we were not simply counting the number of arithmetic operations but actually the number of bit-level operations Therefore the cost of a multiplication or addition was not unity but proportional to the length of the input Had we only counted the number of multiplications for computing xn, that would only be O(log n) This would indeed be the analysis in a uniform cost model where only the number of arithmetic (also logical) operations are counted and does not depend on the length of the operands A very common us of this model is for comparison-based problems like sorting, selection, merging, and many data-structure operations 

27
Enter the search word:
The search word entered is: DNA.
The word occurs at following indexes and in the following sentences!
44-> In the case of one-dimensional, examples can be text editor and DNA analysis
61-> In the text editor, we have 26 characters and some special symbols, whereas in the DNA case, we have four characters of A, C, G, and T
104-> In the DNA analysis, a gene in a few hundred long and the human genome is about 3 billion long

Enter the search phrase:
The search phrase entered is: Pattern matching.
The phrase "Pattern matching" occurs in "﻿Pattern matching is to find a pattern, which is relatively small, in a text, which is supposed to be very large".

